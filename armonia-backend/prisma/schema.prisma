datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

targetRoles         String[]

generator client {
  provider        = "prisma-client-js"
  output          = "../../node_modules/.prisma/client"
  previewFeatures = ["multiSchema"]
  binaryTargets   = ["native", "debian-openssl-3.0.x"]
}

model Amenity {
  id                   String        @id @default(cuid())
  name                 String
  description          String?
  rules                String?
  type                 String? // Added: type for common area
  reservations         Reservation[]
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
}

model Announcement {
  id                  String              @id @default(cuid())
  title               String
  content             String
  type                String // general, emergency, important
  visibility          String // public, role-based
  targetRoles         String[]
  requireConfirmation Boolean
  expiresAt           DateTime?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  createdById         String
  createdBy           User                @relation(fields: [createdById], references: [id])
  attachments         AnnouncementAttachment[]
  readBy              AnnouncementRead[]
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model AnnouncementAttachment {
  id             String   @id @default(cuid())
  announcementId String
  announcement   Announcement @relation(fields: [announcementId], references: [id])
  name           String
  url            String
  type           String
  size           Int
}

model AnnouncementRead {
  announcementId String
  userId         String
  announcement   Announcement @relation(fields: [announcementId], references: [id])
  user           User         @relation(fields: [userId], references: [id])
  readAt         DateTime     @default(now())

  @@id([announcementId, userId])
}

model Assembly {
  id          String      @id @default(cuid())
  title       String
  description String?
  date        DateTime
  type        String // ORDINARY, EXTRAORDINARY
  status      String // SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED
  quorum      Float
  attendance  AssemblyAttendance[]
  votes       AssemblyVote[]
  minutes     AssemblyMinutes[]
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model AssemblyMinutes {
  id          String   @id @default(cuid())
  assemblyId  String
  assembly    Assembly @relation(fields: [assemblyId], references: [id])
  content     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model AssemblyAttendance {
  id          String   @id @default(cuid())
  assemblyId  String
  assembly    Assembly @relation(fields: [assemblyId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  attended    Boolean  @default(false)
  attendedAt  DateTime?
  unitId      String // Added missing field
  checkInTime DateTime? // Added missing field
  notes       String? // Added missing field
  proxyName   String? // Added missing field
  proxyDocument String? // Added missing field
  isDelegate  Boolean // Added missing field
  isOwner     Boolean // Added missing field
}

model BudgetItem {
  id          String   @id @default(cuid())
  budgetId    String
  budget      Budget   @relation(fields: [budgetId], references: [id])
  name        String
  amount      Float
  description String?
}

model Budget {
  id          String   @id @default(cuid())
  title       String
  month       Int
  status      String // DRAFT, APPROVED, REJECTED
  year        Int
  totalAmount Float
  items       BudgetItem[]
  expenses    Expense[]
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  approvedById String?
  approvedBy  User?    @relation(fields: [approvedById], references: [id])
  approvedAt  DateTime?
}

model Camera {
  id          String   @id @default(cuid())
  name        String
  url         String
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model Communication {
  id          String   @id @default(cuid())
  title       String
  content     String
  type        String // ANNOUNCEMENT, MESSAGE
  senderId    String
  sender      User     @relation("SentCommunications", fields: [senderId], references: [id])
  recipientId String?
  recipient   User?    @relation("ReceivedCommunications", fields: [recipientId], references: [id])
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model CommunityEvent {
  id           String    @id @default(cuid())
  title        String
  description  String?
  location     String?
  startDateTime DateTime
  endDateTime  DateTime
  type         String // general, emergency, important
  visibility   String // public, role-based
  targetRoles  String[]
  maxAttendees Int?
  organizerId  String
  organizer    User      @relation(fields: [organizerId], references: [id])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  attachments  EventAttachment[]
  attendees    EventAttendee[]
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model EventAttachment {
  id      String   @id @default(cuid())
  eventId String
  event   CommunityEvent @relation(fields: [eventId], references: [id])
  name    String
  url     String
  type    String
  size    Int
}

model EventAttendee {
  eventId String
  userId  String
  event   CommunityEvent @relation(fields: [eventId], references: [id])
  user    User           @relation(fields: [userId], references: [id])
  status  String // confirmed, tentative, declined
  registeredAt DateTime @default(now())

  @@id([eventId, userId])
}

model Conversation {
  id           String @id @default(cuid())
  type         String // direct, group
  participants ConversationParticipant[]
  messages     Message[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model ConversationParticipant {
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  role           String // member, admin
  joinedAt       DateTime     @default(now())

  @@id([conversationId, userId])
}

model DemoRequest {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  phone       String
  complexName String
  message     String?
  createdAt   DateTime @default(now())
}

model Document {
  id          String   @id @default(cuid())
  name        String
  url         String
  type        String // REGULATION, MINUTES, MANUAL
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model Expense {
  id                   String               @id @default(cuid())
  description          String
  amount               Float
  category             String
  expenseDate          DateTime
  vendor               String?
  invoiceNumber        String?
  notes                String?
  residentialComplexId String
  residentialComplex   ResidentialComplex   @relation(fields: [residentialComplexId], references: [id])
  budgetId             String?
  budget               Budget?              @relation(fields: [budgetId], references: [id])
  approvedById         String?
  approvedBy           User?                @relation(fields: [approvedById], references: [id])
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
}

model Fee {
  id          String   @id @default(cuid())
  title       String
  description String?
  type        String
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id])
  amount      Float
  dueDate     DateTime
  paid        Boolean  @default(false)
  paidAt      DateTime?
  paymentId   String?
  payment     Payment? @relation(fields: [paymentId], references: [id])
  createdAt   DateTime @default(now())
  isRecurring Boolean  @default(false)
  frequency   String?
}

model Financials {
  id          String   @id @default(cuid())
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  // Add fields for financial data
}

model Incident {
  id          String   @id @default(cuid())
  title       String
  description String
  status      String // OPEN, IN_PROGRESS, RESOLVED, CLOSED
  reportedById String
  reportedBy  User     @relation(fields: [reportedById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model Intercom {
  id          String   @id @default(cuid())
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id])
  number      String
}

model IoTDevice {
  id                   String   @id @default(cuid())
  name                 String
  type                 String   // SMART_METER, CAMERA, SENSOR, ACCESS_CONTROL, THERMOSTAT, etc.
  status               String   @default("OFFLINE") // ONLINE, OFFLINE, MAINTENANCE, ERROR, UNKNOWN
  location             String
  description          String?
  serialNumber         String?
  manufacturer         String?
  model                String?
  firmwareVersion      String?
  metadata             Json?
  lastSeen             DateTime?
  installedAt          DateTime @default(now())
  nextMaintenanceAt    DateTime?
  propertyId           String?
  property             Property? @relation(fields: [propertyId], references: [id])
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  // Relaciones con IoT
  iotDevices           IoTDevice[]
  utilityBills         UtilityBill[]
  consumptionAnalytics ConsumptionAnalytics[]
  telemetryData        TelemetryData[]
  smartMeterReadings   SmartMeterReading[]
  alerts               IoTAlert[]
  deviceConfigs        DeviceConfig[]
  utilityReadings      UtilityReading[]
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  @@index([residentialComplexId, type])
  @@index([status])
  @@index([propertyId])
}

model Listing {
  id          String   @id @default(cuid())
  title       String
  description String
  price       Float
  sellerId    String
  seller      User     @relation(fields: [sellerId], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  reportedListings ReportedListing[]
}

model Message {
  id          String   @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  content     String
  senderId    String
  sender      User     @relation("Sender", fields: [senderId], references: [id])
  recipientId String
  recipient   User     @relation("Recipient", fields: [recipientId], references: [id])
  status      String // sent, delivered, read
  createdAt   DateTime @default(now())
  attachments MessageAttachment[]
  readBy      MessageRead[]
}

model MessageAttachment {
  id        String   @id @default(cuid())
  messageId String
  message   Message  @relation(fields: [messageId], references: [id])
  name      String
  url       String
  type      String
  size      Int
}

model MessageRead {
  messageId String
  userId    String
  message   Message  @relation(fields: [messageId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  readAt    DateTime @default(now())

  @@id([messageId, userId])
}

model MicroCreditApplication {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  amount      Float
  status      String // PENDING, APPROVED, REJECTED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Monitoring {
  id          String   @id @default(cuid())
  // Add fields for monitoring data
}

model Notification {
  id                  String    @id @default(cuid())
  recipientId         String
  recipient           User      @relation("RecipientNotifications", fields: [recipientId], references: [id])
  type                String // INFO, WARNING, ERROR, SUCCESS
  title               String
  message             String
  link                String?
  data                Json?
  sourceType          String // SYSTEM, MESSAGE, RESERVATION, ANNOUNCEMENT, EVENT
  sourceId            String?
  priority            String // LOW, MEDIUM, HIGH, URGENT
  read                Boolean   @default(false)
  readAt              DateTime?
  requireConfirmation Boolean   @default(false)
  expiresAt           DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  confirmations       NotificationConfirmation[]
}

model NotificationConfirmation {
  id             String   @id @default(cuid())
  notificationId String
  notification   Notification @relation(fields: [notificationId], references: [id])
  userId         String
  user           User     @relation(fields: [userId], references: [id])
  confirmedAt    DateTime @default(now())
}

model Option {
  id          String   @id @default(cuid())
  questionId  String
  question    Question @relation(fields: [questionId], references: [id])
  text        String
  votes       UserVote[]
  Vote        Vote[]
}

model Package {
  id          String   @id @default(cuid())
  residentId  String
  resident    User     @relation(fields: [residentId], references: [id])
  receivedAt  DateTime @default(now())
  deliveredAt DateTime?
  notes       String?
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model PanicAlert {
  id                   String    @id @default(cuid())
  userId               String
  user                 User      @relation(fields: [userId], references: [id])
  location             String?
  description          String? // Added
  status               String? // Added
  resolvedTime         DateTime? // Added
  resolvedById         String? // Added
  resolvedBy           User?     @relation("ResolvedPanicAlerts", fields: [resolvedById], references: [id]) // Added
  createdAt            DateTime  @default(now())
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model Parking {
  id                   String    @id @default(cuid())
  number               String
  propertyId           String?
  property             Property? @relation(fields: [propertyId], references: [id])
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  type                 String? // Added
  status               String? // Added
  notes                String? // Added
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
}

model PaymentAttempt {
  id          String   @id @default(cuid())
  paymentId   String
  payment     Payment  @relation(fields: [paymentId], references: [id])
  status      String // PENDING, SUCCESS, FAILED
  gateway     String
  gatewayId   String?
  createdAt   DateTime @default(now())
}

model Payment {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  amount      Float
  date        DateTime
  method      String // PSE, CREDIT_CARD
  status      String // PENDING, COMPLETED, FAILED
  transactionId String? @unique
  paymentMethod String?
  fees        Fee[]
  attempts    PaymentAttempt[]
  bankReconciliations BankReconciliation[] // Added
}

model PaymentGatewayConfig {
  id                   String             @id @default(cuid())
  name                 String
  type                 String // Added
  apiKey               String // Added
  secretKey            String // Added
  supportedCurrencies  String[] // Added
  isActive             Boolean            @default(true)
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
}

model Payments {
  id          String   @id @default(cuid())
  // Add fields for payments data
}

model PersonalFinance {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  type        String // Added
  description String // Added
  amount      Float // Added
  date        DateTime // Added
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Pet {
  id                   String    @id @default(cuid())
  name                 String
  breed                String?
  ownerId              String
  owner                User      @relation(fields: [ownerId], references: [id])
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  type                 String? // Added: type for pet
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
}

model Plan {
  id          String   @id @default(cuid())
  name        String
  price       Float
  features    String[]
  residentialComplexes ResidentialComplex[]
}

model PQR {
  id          String   @id @default(cuid())
  title       String
  description String
  type        String // PETITION, COMPLAINT, CLAIM
  status      String // OPEN, IN_PROGRESS, RESOLVED, CLOSED
  reportedById String
  reportedBy  User     @relation(fields: [reportedById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model Project {
  id                   String    @id @default(cuid())
  name                 String
  description          String?
  status               String // PLANNING, IN_PROGRESS, COMPLETED
  startDate            DateTime?
  endDate              DateTime?
  budget               Float?
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  createdById          String // Added
  createdBy            User      @relation("CreatedProjects", fields: [createdById], references: [id]) // Added
  tasks                ProjectTask[] // Added
  updates              ProjectUpdate[] // Added
}

model ProjectTask {
  id           String    @id @default(cuid())
  projectId    String
  project      Project   @relation(fields: [projectId], references: [id])
  title        String
  description  String?
  status       String // TO_DO, IN_PROGRESS, DONE
  assignedToId String?
  assignedTo   User?     @relation("AssignedTasks", fields: [assignedToId], references: [id]) // Re-added fields and references
  dueDate      DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

model ProjectUpdate {
  id          String   @id @default(cuid())
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id])
  title       String
  description String?
  progress    Float
  authorId    String
  author      User     @relation("ProjectUpdates", fields: [authorId], references: [id]) // Re-added fields and references
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Property {
  id                   String    @id @default(cuid())
  type                 String // APARTMENT, HOUSE, OFFICE
  number               String // Changed from unitNumber to number for consistency
  ownerId              String
  owner                User      @relation("Owner", fields: [ownerId], references: [id])
  residentId           String?
  resident             User?     @relation("Resident", fields: [residentId], references: [id])
  fees                 Fee[]
  intercoms            Intercom[]
  parkings             Parking[]
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  residents            Resident[]
  visitors             Visitor[]
  status               String? // Added
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
   // Relaciones con IoT
  iotDevices           IoTDevice[]
  smartMeterReadings   SmartMeterReading[]
  utilityBills         UtilityBill[]
}

model Question {
  id          String   @id @default(cuid())
  surveyId    String
  survey      Survey   @relation(fields: [surveyId], references: [id])
  text        String
  type        String // Added
  options     Option[]
  votes       Vote[]
}

model Report {
  id          String   @id @default(cuid())
  name        String
  data        Json
  generatedById String
  generatedBy User     @relation(fields: [generatedById], references: [id])
  createdAt   DateTime @default(now())
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model ReportedListing {
  id          String   @id @default(cuid())
  listingId   String
  listing     Listing  @relation(fields: [listingId], references: [id])
  reportedById String
  reportedBy  User     @relation(fields: [reportedById], references: [id])
  reason      String
  createdAt   DateTime @default(now())
}

model Reservation {
  id                   String    @id @default(cuid())
  amenityId            String
  amenity              Amenity   @relation(fields: [amenityId], references: [id])
  userId               String
  user                 User      @relation(fields: [userId], references: [id])
  startTime            DateTime
  endTime              DateTime
  status               String // PENDING, CONFIRMED, CANCELLED
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  reservationNotifications ReservationNotification[]
  title                String? // Added
  description          String? // Added
  attendees            String[] // Changed from String[]? to String[]
  requiresPayment      Boolean? // Added
  paymentAmount        Float? // Added
}

model ReservationNotification {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id])
  reservationId String?
  reservation   Reservation? @relation(fields: [reservationId], references: [id])
  type          String // confirmation, cancellation, rejection
  message       String
  isRead        Boolean   @default(false)
  readAt        DateTime?
  migrated      Boolean   @default(false)
  createdAt     DateTime  @default(now())
}

model Resident {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  phone       String?
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id])
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
}

model ResidentialComplex {
  id          String   @id @default(cuid())
  name        String
  address     String
  city        String
  country     String
  planId      String
  plan        Plan     @relation(fields: [planId], references: [id])
  users       User[]
  properties  Property[]
  amenities   Amenity[]
  pets        Pet[]
  vehicles    Vehicle[]
  parkings    Parking[]
  assemblies  Assembly[]
  budgets     Budget[]
  cameras     Camera[]
  documents   Document[]
  iotDevices  IoTDevice[]
  listings    Listing[]
  packages    Package[]
  panicAlerts PanicAlert[]
  pqrs        PQR[]
  projects    Project[]
  reports     Report[]
  serviceProviders ServiceProvider[]
  surveys     Survey[]
  visitors    Visitor[]
  financials  Financials[]
  incidents   Incident[]
  utilityRates UtilityRate[]
  announcements Announcement[]
  communityEvents CommunityEvent[]
  expenses Expense[]
  status       String? // Added
  adminId      String? // Added
  admin        User?     @relation("AdministeredComplexes", fields: [adminId], references: [id]) // Added
  contactEmail String? // Added
  contactPhone String? // Added
  logoUrl      String? // Added
  primaryColor String? // Added
  secondaryColor String? // Added
  isActive     Boolean @default(true) // Added
  securityEvents SecurityEvent[] // Added
  accessAttempts AccessAttempt[] // Added
  bankReconciliations BankReconciliation[] // Added
  
  // Relaciones con IoT
  telemetryData TelemetryData[]
  iotAlerts IoTAlert[]
  deviceConfigs DeviceConfig[]
  utilityBills UtilityBill[]
  smartMeterReadings SmartMeterReading[]
  utilityReadings UtilityReading[]
  consumptionAnalytics ConsumptionAnalytics[]
  utilityRates UtilityRate[]
  paymentGateways PaymentGatewayConfig[]
}

model Review {
  id          String   @id @default(cuid())
  rating      Int
  comment     String?
  serviceProviderId String
  serviceProvider ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  createdAt   DateTime @default(now())
}

model SecurityEvent {
  id                   String    @id @default(cuid())
  type                 String
  description          String
  location             String?
  reportedByUserId     String?
  reportedBy           User?     @relation("ReportedSecurityEvents", fields: [reportedByUserId], references: [id])
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt // Added
}

model AccessAttempt {
  id                   String    @id @default(cuid())
  ipAddress            String
  username             String
  isSuccess            Boolean
  reason               String?
  userId               String?
  user                 User?     @relation("UserAccessAttempts", fields: [userId], references: [id])
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt // Added
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id]) // Added
}

model ServiceProvider {
  id          String   @id @default(cuid())
  name        String
  service     String
  phone       String?
  email       String?
  reviews     Review[]
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model SmartMeterReading {
  id                   String   @id @default(cuid())
  deviceId             String
  device               IoTDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  propertyId           String?
  property             Property? @relation(fields: [propertyId], references: [id])
  reading              Float
  previousReading      Float?
  unit                 String   // kWh, m3, liters, gallons, etc.
  consumption          Float?   // Calculated consumption
  cost                 Float?   // Calculated cost
  timestamp            DateTime
  isAutomatic          Boolean  @default(true)
  source               String   @default("telemetry") // telemetry, manual, api
  additionalData       Json?
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  // Relaciones con facturación
  utilityBills         UtilityBill[]
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  @@index([deviceId, timestamp])
  @@index([propertyId])
  @@index([residentialComplexId, timestamp])
}

model Survey {
  id          String   @id @default(cuid())
  title       String
  description String?
  questions   Question[]
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

// ========== IOT TABLES ==========

model TelemetryData {
  id                   String   @id @default(cuid())
  deviceId             String
  device               IoTDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  dataType             String?  // sensor_reading, status_update, heartbeat, etc.
  payload              Json     // Raw telemetry data
  timestamp            DateTime
  metadata             Json?
  source               String   @default("device") // device, api, manual
  processed            Boolean  @default(false)
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  createdAt            DateTime @default(now())
  
  @@index([deviceId, timestamp])
  @@index([residentialComplexId, processed])
  @@index([timestamp])
}

model IoTAlert {
  id                   String   @id @default(cuid())
  deviceId             String
  device               IoTDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  type                 String   // CONSUMPTION_SPIKE, DEVICE_OFFLINE, THRESHOLD_EXCEEDED, etc.
  severity             String   // LOW, MEDIUM, HIGH, CRITICAL
  status               String   @default("ACTIVE") // ACTIVE, ACKNOWLEDGED, RESOLVED, DISMISSED
  title                String
  message              String
  data                 Json?    // Additional alert data
  acknowledgedBy       String?
  acknowledgedByUser   User?    @relation("AcknowledgedAlerts", fields: [acknowledgedBy], references: [id])
  acknowledgedAt       DateTime?
  resolvedBy           String?
  resolvedByUser       User?    @relation("ResolvedAlerts", fields: [resolvedBy], references: [id])
  resolvedAt           DateTime?
  resolution           String?  // Resolution notes
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  @@index([deviceId, status])
  @@index([residentialComplexId, severity])
  @@index([status, createdAt])
}

model DeviceConfig {
  id                   String   @id @default(cuid())
  deviceId             String
  device               IoTDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  configType           String   // threshold, schedule, alert_settings, etc.
  configKey            String
  configValue          Json     // Configuration value (can be string, number, object, etc.)
  isActive             Boolean  @default(true)
  description          String?
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  @@unique([deviceId, configKey])
  @@index([deviceId, configType])
}

model UtilityBill {
  id                   String   @id @default(cuid())
  propertyId           String
  property             Property @relation(fields: [propertyId], references: [id])
  period               String   // "2024-01", "2024-Q1", etc.
  billingPeriodStart   DateTime
  billingPeriodEnd     DateTime
  utilityType          String   // electricity, water, gas, etc.
  totalConsumption     Float
  unit                 String   // kWh, m3, etc.
  ratePerUnit          Float
  fixedCharges         Float?   // Fixed monthly charges
  taxes                Float?   // Taxes and additional charges
  totalAmount          Float
  status               String   @default("PENDING") // PENDING, SENT, PAID, OVERDUE
  dueDate              DateTime
  paidAt               DateTime?
  paymentReference     String?
  generatedAt          DateTime @default(now())
  generatedBy          String   // AUTOMATIC, MANUAL
  notes                String?
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  // Relaciones con lecturas
  readings             SmartMeterReading[]
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  @@index([propertyId, period])
  @@index([residentialComplexId, status])
  @@index([dueDate])
}
// ========== MODELOS ADICIONALES IOT ==========

model UtilityReading {
  id                   String   @id @default(cuid())
  deviceId             String
  device               IoTDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  propertyId           String?
  property             Property? @relation(fields: [propertyId], references: [id])
  utilityType          String   // electricity, water, gas
  reading              Float    // Lectura actual
  previousReading      Float?   // Lectura anterior
  consumption          Float?   // Consumo calculado
  unit                 String   // kWh, m3, liters
  cost                 Float?   // Costo calculado
  readingDate          DateTime
  isAutomatic          Boolean  @default(true)
  metadata             Json?    // Datos adicionales del sensor
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  // Relaciones con análisis
  analytics            ConsumptionAnalytics[]
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  @@index([deviceId, readingDate])
  @@index([propertyId, utilityType])
  @@index([residentialComplexId, readingDate])
}

model ConsumptionAnalytics {
  id                   String   @id @default(cuid())
  propertyId           String
  property             Property @relation(fields: [propertyId], references: [id])
  utilityType          String   // electricity, water, gas
  period               String   // daily, weekly, monthly, yearly
  periodStart          DateTime
  periodEnd            DateTime
  totalConsumption     Float
  averageConsumption   Float
  peakConsumption      Float
  minConsumption       Float
  consumptionTrend     String   // increasing, decreasing, stable
  anomalyDetected      Boolean  @default(false)
  anomalyScore         Float?   // Puntuación de anomalía (0-1)
  predictedConsumption Float?   // Predicción para el siguiente período
  costAnalysis         Json?    // Análisis de costos detallado
  recommendations      Json?    // Recomendaciones de ahorro
  comparisonData       Json?    // Comparación con períodos anteriores
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  
  // Relaciones
  readings             UtilityReading[]
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  @@index([propertyId, utilityType, period])
  @@index([residentialComplexId, periodStart])
  @@index([anomalyDetected])
  @@unique([propertyId, utilityType, period, periodStart])
}

model UserVote {
  id          String   @id @default(cuid())
  optionId    String
  option      Option   @relation(fields: [optionId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  name        String?
  password    String
  role        String   // ADMIN, RESIDENT, GUARD
  residentialComplexId String?
  residentialComplex ResidentialComplex? @relation(fields: [residentialComplexId], references: [id])
  ownedProperties  Property[] @relation("Owner")
  residentOf  Property[] @relation("Resident")
  reservations Reservation[]
  userVotes       UserVote[]
  pqrs        PQR[]
  incidents   Incident[]
  packages    Package[]
  panicAlerts PanicAlert[]
  listings    Listing[]
  reportedListings ReportedListing[]
  reviews     Review[]
  assemblyAttendance AssemblyAttendance[]
  payments    Payment[]
  microCreditApplications MicroCreditApplication[]
  personalFinances PersonalFinance[]
  sentCommunications Communication[] @relation("SentCommunications")
  receivedCommunications Communication[] @relation("ReceivedCommunications")
  messagesSent Message[] @relation("Sender")
  messagesReceived Message[] @relation("Recipient")
  reportsGenerated Report[]
  pets        Pet[]
  vehicles    Vehicle[]
  Resident    Resident[]
  assemblyVoteRecords AssemblyVoteRecord[]
  votes       Vote[]
  announcementReads AnnouncementRead[]
  eventAttendees EventAttendee[]
  notifications Notification[] @relation("RecipientNotifications")
  notificationConfirmations NotificationConfirmation[]
  reservationNotifications ReservationNotification[]
  createdAnnouncements Announcement[]
  organizedEvents CommunityEvent[]
  phoneNumber String?
  deviceToken String?
  conversationParticipants ConversationParticipant[]
  messageReads MessageRead[]
  approvedBudgets Budget[]
  approvedExpenses Expense[]
  ResolvedPanicAlerts PanicAlert[] @relation("ResolvedPanicAlerts")
  assignedTasks ProjectTask[] @relation("AssignedTasks") // Re-added fields and references
  projectUpdates ProjectUpdate[] @relation("ProjectUpdates") // Re-added fields and references
  createdProjects Project[] @relation("CreatedProjects")
  administeredComplexes ResidentialComplex[] @relation("AdministeredComplexes") // Added
  reportedSecurityEvents SecurityEvent[] @relation("ReportedSecurityEvents") // Added
  userAccessAttempts AccessAttempt[] @relation("UserAccessAttempts") // Added
  processedReconciliations BankReconciliation[] @relation("ProcessedReconciliations") // Added

  // Relaciones con documentos
  uploadedDocuments Document[] @relation("UploadedDocuments")
  updatedDocuments Document[] @relation("UpdatedDocuments")
  approvedDocuments Document[] @relation("ApprovedDocuments")
  sharedDocuments DocumentShare[] @relation("SharedDocuments")
  receivedDocuments DocumentShare[] @relation("ReceivedDocuments")
  documentComments DocumentComment[] @relation("DocumentComments")
  documentActivities DocumentActivity[] @relation("DocumentActivities")
  
  // Relaciones con IoT
  acknowledgedAlerts IoTAlert[] @relation("AcknowledgedAlerts")
  resolvedAlerts IoTAlert[] @relation("ResolvedAlerts")

  userAccessAttempts AccessAttempt[] @relation("UserAccessAttempts") // Added
  paymentMethods PaymentMethod[]
  paymentNotifications PaymentNotification[]
}

model UtilityRate {
  id          String   @id @default(cuid())
  name        String
  rate        Float
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model Vehicle {
  id                   String    @id @default(cuid())
  plate                String // Changed from licensePlate to plate for consistency
  brand                String?
  model                String?
  ownerId              String
  owner                User      @relation(fields: [ownerId], references: [id])
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
}

model Visitor {
  id          String   @id @default(cuid())
  name        String
  idNumber    String?
  entryTime   DateTime
  exitTime    DateTime?
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id])
  residentialComplexId String
  residentialComplex ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
}

model Vote {
  id          String   @id @default(cuid())
  questionId  String
  question    Question @relation(fields: [questionId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  optionId    String
  option      Option   @relation(fields: [optionId], references: [id])
  createdAt   DateTime @default(now())
}

model AssemblyVote {
  id          String   @id @default(cuid())
  assemblyId  String
  assembly    Assembly @relation(fields: [assemblyId], references: [id])
  question    String
  options     String[]
  votes       AssemblyVoteRecord[]
}

model AssemblyVoteRecord {
  id          String   @id @default(cuid())
  assemblyVoteId String
  assemblyVote   AssemblyVote @relation(fields: [assemblyVoteId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  option      String
  coefficient Float? // Added missing field
  createdAt   DateTime @default(now())
}
model BankReconciliation {
  id                   String   @id @default(cuid())
  transactionId        String   @unique
  date                 DateTime
  description          String
  amount               Float
  type                 String   // CREDIT, DEBIT
  reference            String?
  account              String?
  bankName             String?
  accountNumber        String?
  status               String   // MATCHED, UNMATCHED, PARTIALLY_MATCHED, MANUAL_REVIEW
  paymentId            String?
  payment              Payment? @relation(fields: [paymentId], references: [id])
  confidence           Float?
  reason               String?
  suggestions          Json?
  notes                String?
  processedById        String?
  processedBy          User?    @relation("ProcessedReconciliations", fields: [processedById], references: [id])
  residentialComplexId String
  residentialComplex   ResidentialComplex @relation(fields: [residentialComplexId], references: [id])
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  processedAt          DateTime?
}
// ========================================
// PAYMENT GATEWAY MODELS
// ========================================

model Transaction {
  id                   String               @id @default(cuid())
  paymentId            String
  payment              Payment              @relation(fields: [paymentId], references: [id])
  paymentGatewayId     String
  paymentGateway       PaymentGatewayConfig? @relation(fields: [paymentGatewayId], references: [id])
  amount               Float
  currency             String
  type                 String // PAYMENT, REFUND, CHARGEBACK
  status               String // PENDING, PROCESSING, COMPLETED, FAILED, CANCELLED
  gatewayTransactionId String?
  gatewayReference     String?
  gatewayResponse      Json? // Full response from gateway
  processingFee        Float?
  netAmount            Float? // Amount after fees
  description          String?
  metadata             Json?
  ipAddress            String?
  userAgent            String?
  webhookVerified      Boolean              @default(false)
  reconciled           Boolean              @default(false)
  reconciledAt         DateTime?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  completedAt          DateTime?

  @@index([paymentGatewayId])
  @@index([status])
  @@index([createdAt])
}

model PaymentMethod {
  id                   String    @id @default(cuid())
  userId               String
  user                 User      @relation(fields: [userId], references: [id])
  type                 String // CREDIT_CARD, DEBIT_CARD, BANK_ACCOUNT, PAYPAL
  provider             String // STRIPE, PAYPAL, PSE
  gatewayMethodId      String? // ID from payment gateway
  isDefault            Boolean   @default(false)
  isActive             Boolean   @default(true)
  // Card details (masked/tokenized)
  last4                String?
  brand                String? // visa, mastercard, amex
  expiryMonth          Int?
  expiryYear           Int?
  // Bank details (for PSE/bank transfers)
  bankName             String?
  bankCode             String?
  accountType          String? // SAVINGS, CHECKING
  // PayPal details
  paypalEmail          String?
  // Metadata
  name                 String? // User-defined name for this method
  metadata             Json?
  payments             Payment[]
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  @@index([userId])
  @@index([type])
}

model WebhookEvent {
  id                String   @id @default(cuid())
  provider          String // STRIPE, PAYPAL, PSE
  eventType         String // payment.succeeded, payment.failed, etc.
  eventId           String // Provider's event ID
  paymentId         String?
  payment           Payment? @relation(fields: [paymentId], references: [id])
  processed         Boolean  @default(false)
  processedAt       DateTime?
  retryCount        Int      @default(0)
  maxRetries        Int      @default(3)
  rawPayload        Json // Full webhook payload
  signature         String? // Webhook signature for verification
  verified          Boolean  @default(false)
  errorMessage      String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([provider, eventId])
  @@index([processed])
  @@index([eventType])
}

model PaymentRefund {
  id                String   @id @default(cuid())
  paymentId         String
  payment           Payment  @relation(fields: [paymentId], references: [id])
  amount            Float
  currency          String
  reason            String // REQUESTED_BY_CUSTOMER, DUPLICATE, FRAUDULENT
  status            String // PENDING, PROCESSING, SUCCEEDED, FAILED, CANCELLED
  gatewayRefundId   String?
  gatewayResponse   Json?
  processedBy       String? // User ID who processed the refund
  notes             String?
  metadata          Json?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  processedAt       DateTime?

  @@index([paymentId])
  @@index([status])
}

model PaymentNotification {
  id             String   @id @default(cuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id])
  paymentId      String?
  payment        Payment? @relation(fields: [paymentId], references: [id])
  type           String // PAYMENT_RECEIVED, PAYMENT_FAILED, REFUND_PROCESSED
  title          String
  message        String
  isRead         Boolean  @default(false)
  readAt         DateTime?
  sentViaEmail   Boolean  @default(false)
  sentViaSMS     Boolean  @default(false)
  sentViaApp     Boolean  @default(true)
  metadata       Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([userId])
  @@index([isRead])
}