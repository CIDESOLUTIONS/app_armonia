// src/hooks/useReservationsWithPayments.ts\nimport { useState, useEffect, useCallback } from 'react';\nimport { useSession } from 'next-auth/react';\nimport { useToast } from '@/components/ui/use-toast';\n\n// Interfaces\ninterface CommonArea {\n  id: number;\n  name: string;\n  description: string;\n  location: string;\n  capacity: number;\n  imageUrl?: string;\n  isActive: boolean;\n  requiresApproval: boolean;\n  hasFee: boolean;\n  feeAmount?: number;\n  availabilityConfig?: AvailabilityConfig;\n  reservationRules?: ReservationRule[];\n}\n\ninterface AvailabilityConfig {\n  mondayStart?: string;\n  mondayEnd?: string;\n  tuesdayStart?: string;\n  tuesdayEnd?: string;\n  wednesdayStart?: string;\n  wednesdayEnd?: string;\n  thursdayStart?: string;\n  thursdayEnd?: string;\n  fridayStart?: string;\n  fridayEnd?: string;\n  saturdayStart?: string;\n  saturdayEnd?: string;\n  sundayStart?: string;\n  sundayEnd?: string;\n  holidaysAvailable: boolean;\n}\n\ninterface ReservationRule {\n  id: number;\n  name: string;\n  description: string;\n  maxDurationHours: number;\n  minDurationHours: number;\n  maxAdvanceDays: number;\n  minAdvanceDays: number;\n  maxReservationsPerMonth: number;\n  maxReservationsPerWeek: number;\n  allowCancellation: boolean;\n  cancellationHours: number;\n}\n\ninterface Reservation {\n  id: number;\n  commonAreaId: number;\n  userId: number;\n  propertyId: number;\n  title: string;\n  description?: string;\n  startDateTime: Date | string;\n  endDateTime: Date | string;\n  status: 'PENDING' | 'APPROVED' | 'REJECTED' | 'CANCELLED' | 'COMPLETED';\n  attendees: number;\n  requiresPayment: boolean;\n  paymentAmount?: number;\n  paymentStatus?: string;\n  rejectionReason?: string;\n  approvedById?: number;\n  approvedAt?: Date | string;\n  cancellationReason?: string;\n  cancelledAt?: Date | string;\n  createdAt: Date | string;\n  updatedAt: Date | string;\n  commonArea?: CommonArea;\n}\n\ninterface CalendarEvent {\n  id: number;\n  title: string;\n  start: Date;\n  end: Date;\n  status: string;\n  resource?: Reservation;\n}\n\ninterface ReservationForm {\n  title: string;\n  description: string;\n  startDateTime: string;\n  endDateTime: string;\n  attendees: number;\n  propertyId: number;\n}\n\ninterface PaymentInfo {\n  transactionId: string;\n  paymentUrl?: string;\n  amount: number;\n  currency: string;\n  expiresAt?: Date;\n  status: string;\n}\n\ninterface UseReservationsWithPaymentsReturn {\n  // Estados de datos\n  commonAreas: CommonArea[];\n  selectedArea: CommonArea | null;\n  myReservations: Reservation[];\n  calendarEvents: CalendarEvent[];\n  viewDate: Date;\n  \n  // Estados de carga\n  isLoading: boolean;\n  isCreatingReservation: boolean;\n  \n  // Estados de formulario\n  reservationForm: ReservationForm;\n  \n  // Estados de UI\n  isReservationDialogOpen: boolean;\n  selectedReservation: Reservation | null;\n  isDetailDialogOpen: boolean;\n  isPaymentModalOpen: boolean;\n  \n  // Funciones de manejo de datos\n  setSelectedArea: (area: CommonArea | null) => void;\n  setViewDate: (date: Date) => void;\n  fetchReservations: () => Promise<void>;\n  \n  // Funciones de formulario\n  setReservationForm: (form: ReservationForm) => void;\n  resetReservationForm: () => void;\n  \n  // Funciones de UI\n  setIsReservationDialogOpen: (open: boolean) => void;\n  setSelectedReservation: (reservation: Reservation | null) => void;\n  setIsDetailDialogOpen: (open: boolean) => void;\n  setIsPaymentModalOpen: (open: boolean) => void;\n  \n  // Funciones de acciones\n  handleCreateReservation: () => Promise<void>;\n  handleCancelReservation: (id: number) => Promise<void>;\n  handleEventClick: (event: CalendarEvent) => void;\n  handleNewReservation: () => void;\n  handlePaymentComplete: () => void;\n  \n  // Funciones de pagos\n  createPaymentForReservation: (reservationId: number) => Promise<PaymentInfo>;\n  getPaymentStatus: (reservationId: number) => Promise<any>;\n}\n\nexport const useReservationsWithPayments = (): UseReservationsWithPaymentsReturn => {\n  const { data: session } = useSession();\n  const { toast } = useToast();\n  \n  // Estados de datos\n  const [commonAreas, setCommonAreas] = useState<CommonArea[]>([]);\n  const [selectedArea, setSelectedArea] = useState<CommonArea | null>(null);\n  const [myReservations, setMyReservations] = useState<Reservation[]>([]);\n  const [calendarEvents, setCalendarEvents] = useState<CalendarEvent[]>([]);\n  const [viewDate, setViewDate] = useState<Date>(new Date());\n  \n  // Estados de carga\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [isCreatingReservation, setIsCreatingReservation] = useState<boolean>(false);\n  \n  // Estados de formulario\n  const [reservationForm, setReservationForm] = useState<ReservationForm>({\n    title: '',\n    description: '',\n    startDateTime: '',\n    endDateTime: '',\n    attendees: 1,\n    propertyId: 0\n  });\n  \n  // Estados de UI\n  const [isReservationDialogOpen, setIsReservationDialogOpen] = useState<boolean>(false);\n  const [selectedReservation, setSelectedReservation] = useState<Reservation | null>(null);\n  const [isDetailDialogOpen, setIsDetailDialogOpen] = useState<boolean>(false);\n  const [isPaymentModalOpen, setIsPaymentModalOpen] = useState<boolean>(false);\n\n  // Cargar áreas comunes al iniciar\n  useEffect(() => {\n    const fetchCommonAreas = async () => {\n      try {\n        const response = await fetch('/api/common-areas?active=true');\n        if (response.ok) {\n          const data = await response.json();\n          setCommonAreas(data);\n          if (data.length > 0) {\n            setSelectedArea(data[0]);\n          }\n        } else {\n          toast({\n            title: 'Error',\n            description: 'No se pudieron cargar las áreas comunes',\n            variant: 'destructive'\n          });\n        }\n      } catch (error) {\n        console.error('Error al cargar áreas comunes:', error);\n        toast({\n          title: 'Error',\n          description: 'No se pudieron cargar las áreas comunes',\n          variant: 'destructive'\n        });\n      }\n    };\n    \n    fetchCommonAreas();\n  }, [toast]);\n\n  // Función para cargar reservas\n  const fetchReservations = useCallback(async () => {\n    if (!selectedArea) return;\n    \n    setIsLoading(true);\n    \n    try {\n      // Calcular rango de fechas para la vista actual (mes)\n      const startDate = new Date(viewDate.getFullYear(), viewDate.getMonth(), 1);\n      const endDate = new Date(viewDate.getFullYear(), viewDate.getMonth() + 1, 0);\n      \n      // Cargar disponibilidad del área común\n      const availabilityResponse = await fetch(\n        `/api/common-areas/${selectedArea.id}/availability?startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`\n      );\n      \n      if (!availabilityResponse.ok) {\n        throw new Error('Error al cargar disponibilidad');\n      }\n      \n      const availabilityData = await availabilityResponse.json();\n      \n      // Cargar mis reservas\n      const myReservationsResponse = await fetch(\n        `/api/reservations?commonAreaId=${selectedArea.id}`\n      );\n      \n      if (!myReservationsResponse.ok) {\n        throw new Error('Error al cargar mis reservas');\n      }\n      \n      const myReservationsData = await myReservationsResponse.json();\n      setMyReservations(myReservationsData);\n      \n      // Convertir reservas a eventos de calendario\n      const events: CalendarEvent[] = [];\n      \n      // Agregar slots ocupados\n      if (availabilityData.occupiedSlots) {\n        availabilityData.occupiedSlots.forEach((slot: any) => {\n          events.push({\n            id: slot.reservationId,\n            title: 'Reservado',\n            start: new Date(slot.startDateTime),\n            end: new Date(slot.endDateTime),\n            status: slot.status\n          });\n        });\n      }\n      \n      // Agregar mis reservas con más detalle\n      myReservationsData.forEach((reservation: Reservation) => {\n        // Buscar si ya existe un evento para esta reserva\n        const existingEventIndex = events.findIndex(event => event.id === reservation.id);\n        \n        // Si existe, actualizar con más detalle\n        if (existingEventIndex >= 0) {\n          events[existingEventIndex] = {\n            id: reservation.id,\n            title: reservation.title,\n            start: new Date(reservation.startDateTime),\n            end: new Date(reservation.endDateTime),\n            status: reservation.status,\n            resource: reservation\n          };\n        } else {\n          // Si no existe, agregar nuevo evento\n          events.push({\n            id: reservation.id,\n            title: reservation.title,\n            start: new Date(reservation.startDateTime),\n            end: new Date(reservation.endDateTime),\n            status: reservation.status,\n            resource: reservation\n          });\n        }\n      });\n      \n      setCalendarEvents(events);\n    } catch (error) {\n      console.error('Error al cargar reservas:', error);\n      toast({\n        title: 'Error',\n        description: 'No se pudieron cargar las reservas',\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [selectedArea, viewDate, toast]);\n\n  // Cargar reservas cuando cambia el área seleccionada o la fecha\n  useEffect(() => {\n    if (selectedArea) {\n      fetchReservations();\n    }\n  }, [selectedArea, viewDate, fetchReservations]);\n\n  // Función para crear una nueva reserva\n  const handleCreateReservation = async () => {\n    if (!selectedArea) {\n      toast({\n        title: 'Error',\n        description: 'Seleccione un área común',\n        variant: 'destructive'\n      });\n      return;\n    }\n    \n    setIsCreatingReservation(true);\n    \n    try {\n      const response = await fetch('/api/reservations', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          commonAreaId: selectedArea.id,\n          propertyId: reservationForm.propertyId,\n          title: reservationForm.title,\n          description: reservationForm.description,\n          startDateTime: new Date(reservationForm.startDateTime).toISOString(),\n          endDateTime: new Date(reservationForm.endDateTime).toISOString(),\n          attendees: reservationForm.attendees\n        })\n      });\n      \n      if (response.ok) {\n        const data = await response.json();\n        \n        // Si la reserva requiere pago, mostrar modal de pago\n        if (selectedArea.hasFee && data.reservation) {\n          setSelectedReservation(data.reservation);\n          setIsPaymentModalOpen(true);\n        }\n        \n        toast({\n          title: 'Reserva creada',\n          description: selectedArea.requiresApproval \n            ? 'Su solicitud de reserva ha sido enviada y está pendiente de aprobación'\n            : selectedArea.hasFee\n            ? 'Reserva creada. Complete el pago para confirmarla.'\n            : 'Su reserva ha sido confirmada exitosamente',\n        });\n        \n        setIsReservationDialogOpen(false);\n        resetReservationForm();\n        fetchReservations();\n      } else {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Error al crear la reserva');\n      }\n    } catch (error) {\n      console.error('Error al crear reserva:', error);\n      toast({\n        title: 'Error',\n        description: error instanceof Error ? error.message : 'Error al crear la reserva',\n        variant: 'destructive'\n      });\n    } finally {\n      setIsCreatingReservation(false);\n    }\n  };\n\n  // Función para cancelar una reserva\n  const handleCancelReservation = async (id: number) => {\n    try {\n      const response = await fetch(`/api/reservations/${id}`, {\n        method: 'DELETE',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          cancellationReason: 'Cancelada por el usuario'\n        })\n      });\n      \n      if (response.ok) {\n        toast({\n          title: 'Reserva cancelada',\n          description: 'La reserva ha sido cancelada exitosamente'\n        });\n        setIsDetailDialogOpen(false);\n        fetchReservations();\n      } else {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Error al cancelar la reserva');\n      }\n    } catch (error) {\n      console.error('Error al cancelar reserva:', error);\n      toast({\n        title: 'Error',\n        description: error instanceof Error ? error.message : 'Error al cancelar la reserva',\n        variant: 'destructive'\n      });\n    }\n  };\n\n  // Función para mostrar detalle de una reserva\n  const handleEventClick = (event: CalendarEvent) => {\n    if (event.resource) {\n      setSelectedReservation(event.resource);\n      setIsDetailDialogOpen(true);\n    }\n  };\n\n  // Función para resetear el formulario de reserva\n  const resetReservationForm = () => {\n    setReservationForm({\n      title: '',\n      description: '',\n      startDateTime: '',\n      endDateTime: '',\n      attendees: 1,\n      propertyId: 1 // Valor por defecto\n    });\n  };\n\n  // Función para abrir el diálogo de nueva reserva\n  const handleNewReservation = () => {\n    resetReservationForm();\n    setIsReservationDialogOpen(true);\n  };\n\n  // Función para manejar pago completado\n  const handlePaymentComplete = () => {\n    setIsPaymentModalOpen(false);\n    setSelectedReservation(null);\n    fetchReservations(); // Recargar para mostrar estado actualizado\n  };\n\n  // Función para crear pago para una reserva\n  const createPaymentForReservation = async (reservationId: number): Promise<PaymentInfo> => {\n    try {\n      const response = await fetch(`/api/reservations/${reservationId}/payment`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          returnUrl: `${window.location.origin}/reservations/payment-result`\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Error al crear el pago');\n      }\n\n      const data = await response.json();\n      return data.payment;\n    } catch (error) {\n      console.error('Error creando pago:', error);\n      throw error;\n    }\n  };\n\n  // Función para obtener estado del pago\n  const getPaymentStatus = async (reservationId: number) => {\n    try {\n      const response = await fetch(`/api/reservations/${reservationId}/payment`);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Error al obtener estado del pago');\n      }\n\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error('Error obteniendo estado del pago:', error);\n      throw error;\n    }\n  };\n\n  return {\n    // Estados de datos\n    commonAreas,\n    selectedArea,\n    myReservations,\n    calendarEvents,\n    viewDate,\n    \n    // Estados de carga\n    isLoading,\n    isCreatingReservation,\n    \n    // Estados de formulario\n    reservationForm,\n    \n    // Estados de UI\n    isReservationDialogOpen,\n    selectedReservation,\n    isDetailDialogOpen,\n    isPaymentModalOpen,\n    \n    // Funciones de manejo de datos\n    setSelectedArea,\n    setViewDate,\n    fetchReservations,\n    \n    // Funciones de formulario\n    setReservationForm,\n    resetReservationForm,\n    \n    // Funciones de UI\n    setIsReservationDialogOpen,\n    setSelectedReservation,\n    setIsDetailDialogOpen,\n    setIsPaymentModalOpen,\n    \n    // Funciones de acciones\n    handleCreateReservation,\n    handleCancelReservation,\n    handleEventClick,\n    handleNewReservation,\n    handlePaymentComplete,\n    \n    // Funciones de pagos\n    createPaymentForReservation,\n    getPaymentStatus\n  };\n};\n